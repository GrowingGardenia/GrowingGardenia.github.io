<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>算法学习 二叉树 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="算法学习_极客时间 树&amp;amp;二叉树 时间：20190515 leetcode：98、236、235 二叉树二叉树：每个节点都最多两个孩子节点 二叉搜索树：左右子树节点间有大小关系，左子树上所有节点的值均小于根节点的值，右子树上所有节点的值均大于根节点的值，左右子树也是二叉搜索树。 查找时间复杂度平均O(logn)，最坏O(n)">
<meta name="keywords" content="算法,二叉树,树">
<meta property="og:type" content="article">
<meta property="og:title" content="算法学习 二叉树">
<meta property="og:url" content="http://yoursite.com/2019/05/15/算法学习-二叉树/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="算法学习_极客时间 树&amp;amp;二叉树 时间：20190515 leetcode：98、236、235 二叉树二叉树：每个节点都最多两个孩子节点 二叉搜索树：左右子树节点间有大小关系，左子树上所有节点的值均小于根节点的值，右子树上所有节点的值均大于根节点的值，左右子树也是二叉搜索树。 查找时间复杂度平均O(logn)，最坏O(n)">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-05-15T05:04:48.655Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="算法学习 二叉树">
<meta name="twitter:description" content="算法学习_极客时间 树&amp;amp;二叉树 时间：20190515 leetcode：98、236、235 二叉树二叉树：每个节点都最多两个孩子节点 二叉搜索树：左右子树节点间有大小关系，左子树上所有节点的值均小于根节点的值，右子树上所有节点的值均大于根节点的值，左右子树也是二叉搜索树。 查找时间复杂度平均O(logn)，最坏O(n)">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-算法学习-二叉树" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/15/算法学习-二叉树/" class="article-date">
  <time datetime="2019-05-15T05:00:59.000Z" itemprop="datePublished">2019-05-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/算法/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      算法学习 二叉树
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>算法学习_极客时间 树&amp;二叉树</p>
<p>时间：20190515 <br><br>leetcode：98、236、235</p>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树：每个节点都最多两个孩子节点</p>
<p>二叉搜索树：左右子树节点间有大小关系，左子树上所有节点的值均小于根节点的值，右子树上所有节点的值均大于根节点的值，左右子树也是二叉搜索树。</p>
<p>查找时间复杂度平均O(logn)，最坏O(n)</p>
<a id="more"></a>
<h2 id="题目1-验证二叉搜索树-leetcode-98"><a href="#题目1-验证二叉搜索树-leetcode-98" class="headerlink" title="题目1 验证二叉搜索树 leetcode#98"></a>题目1 验证二叉搜索树 leetcode#98</h2><ul>
<li><strong>题目</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Given a binary tree, determine if it is a valid binary search tree (BST).</span><br><span class="line"></span><br><span class="line">Assume a BST is defined as follows:</span><br><span class="line"></span><br><span class="line">The left subtree of a node contains only nodes with keys less than the node&apos;s key.</span><br><span class="line">The right subtree of a node contains only nodes with keys greater than the node&apos;s key.</span><br><span class="line">Both the left and right subtrees must also be binary search trees.</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">    2</span><br><span class="line">   / \</span><br><span class="line">  1   3</span><br><span class="line"></span><br><span class="line">Input: [2,1,3]</span><br><span class="line">Output: true</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  1   4</span><br><span class="line">     / \</span><br><span class="line">    3   6</span><br><span class="line"></span><br><span class="line">Input: [5,1,4,null,null,3,6]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: The root node&apos;s value is 5 but its right child&apos;s value is 4.</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">给定一个二叉树，判断其是否是一个有效的二叉搜索树。</span><br><span class="line"></span><br><span class="line">假设一个二叉搜索树具有如下特征：</span><br><span class="line"></span><br><span class="line">节点的左子树只包含小于当前节点的数。</span><br><span class="line">节点的右子树只包含大于当前节点的数。</span><br><span class="line">所有左子树和右子树自身必须也是二叉搜索树。</span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">    2</span><br><span class="line">   / \</span><br><span class="line">  1   3</span><br><span class="line">输出: true</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  1   4</span><br><span class="line">     / \</span><br><span class="line">    3   6</span><br><span class="line">输出: false</span><br><span class="line">解释: 输入为: [5,1,4,null,null,3,6]。</span><br><span class="line">     根节点的值为 5 ，但是其右子节点值为 4 。</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>思路</strong></li>
</ul>
<p>1）中序遍历，看是否为升序<br><br>2）递归函数设计，传递最小和最大值，通过取左子树的最大值和右子树的最小值与根节点进行比较。<br><br>时间复杂度均为O(n)</p>
<ul>
<li><strong>实例</strong></li>
</ul>
<p>实例1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># Definition for a binary tree node.</span><br><span class="line"># class TreeNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val = x</span><br><span class="line">#         self.left = None</span><br><span class="line">#         self.right = None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def isValidBST(self, root: TreeNode) -&gt; bool:</span><br><span class="line">        inorder = self.inorder(root)</span><br><span class="line">        return inorder == list(sorted(set(inorder)))</span><br><span class="line">    </span><br><span class="line">    def inorder(self, root: TreeNode):</span><br><span class="line">        if root is None:</span><br><span class="line">            return []</span><br><span class="line">        return self.inorder(root.left) + [root.val] + self.inorder(root.right)</span><br></pre></td></tr></table></figure></p>
<p>实例2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def isValidBST(self, root: TreeNode) -&gt; bool:</span><br><span class="line">        self.prev = None</span><br><span class="line">        return self.helper(root)</span><br><span class="line">    </span><br><span class="line">    def helper(self, root: TreeNode):</span><br><span class="line">        if root == None:</span><br><span class="line">            return True</span><br><span class="line">        if not self.helper(root.left):</span><br><span class="line">            return False</span><br><span class="line">        if self.prev and self.prev.val &gt;= root.val:</span><br><span class="line">            return False</span><br><span class="line">        self.prev = root</span><br><span class="line">        return self.helper(root.right)</span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>结果</strong></li>
</ul>
<p>实例1：<br><br>执行用时 : 68 ms, 在Validate Binary Search Tree的Python3提交中击败了90.46% 的用户<br><br>内存消耗 : 16.4 MB, 在Validate Binary Search Tree的Python3提交中击败了21.88% 的用户</p>
<p>实例2：<br><br>执行用时 : 60 ms, 在Validate Binary Search Tree的Python3提交中击败了98.54% 的用户<br><br>内存消耗 : 16.1 MB, 在Validate Binary Search Tree的Python3提交中击败了51.90% 的用户</p>
<h2 id="题目2-二叉树最小公共祖先-leetcode-236"><a href="#题目2-二叉树最小公共祖先-leetcode-236" class="headerlink" title="题目2 二叉树最小公共祖先  leetcode#236"></a>题目2 二叉树最小公共祖先  leetcode#236</h2><ul>
<li><strong>题目</strong></li>
</ul>
<p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">题目链接</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</span><br><span class="line"></span><br><span class="line">According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”</span><br><span class="line"></span><br><span class="line">Given the following binary tree:  root = [3,5,1,6,2,0,8,null,null,7,4]</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The LCA of nodes 5 and 1 is 3.</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">All of the nodes&apos; values will be unique.</span><br><span class="line">p and q are different and both values will exist in the binary tree.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</span><br><span class="line"></span><br><span class="line">百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</span><br><span class="line"></span><br><span class="line">例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1</span><br><span class="line">输出: 3</span><br><span class="line">解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4</span><br><span class="line">输出: 5</span><br><span class="line">解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">说明:</span><br><span class="line"></span><br><span class="line">所有节点的值都是唯一的。</span><br><span class="line">p、q 为不同节点且均存在于给定的二叉树中。</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>思路</strong><br><br>1）找到回根节点的路径，时间复杂度O(n)<br><br>2）递归：findPorQ(root, p, q) ， 如果root==p 或 root==q， 直接返回root， 否则分别对左子树和右子树调用该函数。时间复杂度O(n)</p>
</li>
<li><p><strong>实例</strong><br><br>实例1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># class TreeNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val = x</span><br><span class="line">#         self.left = None</span><br><span class="line">#         self.right = None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def lowestCommonAncestor(self, root: &apos;TreeNode&apos;, p: &apos;TreeNode&apos;, q: &apos;TreeNode&apos;) -&gt; &apos;TreeNode&apos;:</span><br><span class="line">        if root == None:</span><br><span class="line">            return None</span><br><span class="line">        if root == p or root == q:</span><br><span class="line">            return root</span><br><span class="line">        left = self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        right = self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        if left != None:</span><br><span class="line">            if right != None:</span><br><span class="line">                return root</span><br><span class="line">            else:</span><br><span class="line">                return left</span><br><span class="line">        return right</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>简洁版<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Definition for a binary tree node.</span><br><span class="line"># class TreeNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val = x</span><br><span class="line">#         self.left = None</span><br><span class="line">#         self.right = None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def lowestCommonAncestor(self, root: &apos;TreeNode&apos;, p: &apos;TreeNode&apos;, q: &apos;TreeNode&apos;) -&gt; &apos;TreeNode&apos;:</span><br><span class="line">        if root == None or root == p or root == q: return root</span><br><span class="line">        left = self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        right = self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        return right if left == None else left if right == None else root</span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>结果</strong></li>
</ul>
<p>实例1：<br><br>执行用时 : 196 ms, 在Lowest Common Ancestor of a Binary Tree的Python3提交中击败了13.69% 的用户<br><br>内存消耗 : 24.3 MB, 在Lowest Common Ancestor of a Binary Tree的Python3提交中击败了97.21% 的用户</p>
<p>简洁版：<br><br>执行用时 : 124 ms, 在Lowest Common Ancestor of a Binary Tree的Python3提交中击败了50.55% 的用户<br><br>内存消耗 : 24.3 MB, 在Lowest Common Ancestor of a Binary Tree的Python3提交中击败了97.21% 的用户</p>
<h2 id="题目3-二叉搜索树的最小公共祖先-leetcode-235"><a href="#题目3-二叉搜索树的最小公共祖先-leetcode-235" class="headerlink" title="题目3 二叉搜索树的最小公共祖先  leetcode#235"></a>题目3 二叉搜索树的最小公共祖先  leetcode#235</h2><ul>
<li><strong>题目</strong></li>
</ul>
<p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/" target="_blank" rel="noopener">题目链接</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.</span><br><span class="line"></span><br><span class="line">According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”</span><br><span class="line"></span><br><span class="line">Given binary search tree:  root = [6,2,8,0,4,7,9,null,null,3,5]</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: The LCA of nodes 2 and 8 is 6.</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.</span><br><span class="line"> </span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">All of the nodes&apos; values will be unique.</span><br><span class="line">p and q are different and both values will exist in the BST.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</span><br><span class="line"></span><br><span class="line">百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</span><br><span class="line"></span><br><span class="line">例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8</span><br><span class="line">输出: 6 </span><br><span class="line">解释: 节点 2 和节点 8 的最近公共祖先是 6。</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4</span><br><span class="line">输出: 2</span><br><span class="line">解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</span><br><span class="line"> </span><br><span class="line">说明:</span><br><span class="line"></span><br><span class="line">所有节点的值都是唯一的。</span><br><span class="line">p、q 为不同节点且均存在于给定的二叉搜索树中。</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>思路</strong></li>
</ul>
<p>利用二叉搜索树的特性，可以通过比较所找节点与根节点的大小确认其所在的子树，若两节点都在左子树或右子树，则递归搜索，若一边一个，则返回根节点。</p>
<ul>
<li><strong>实例</strong><br><br>实例1：利用递归<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># Definition for a binary tree node.</span><br><span class="line"># class TreeNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val = x</span><br><span class="line">#         self.left = None</span><br><span class="line">#         self.right = None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def lowestCommonAncestor(self, root: &apos;TreeNode&apos;, p: &apos;TreeNode&apos;, q: &apos;TreeNode&apos;) -&gt; &apos;TreeNode&apos;:</span><br><span class="line">        if p.val &gt; root.val &lt; q.val:</span><br><span class="line">            return self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        elif p.val &lt; root.val &gt; q.val:</span><br><span class="line">            return self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        else: return root</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>实例2：非递归<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># Definition for a binary tree node.</span><br><span class="line"># class TreeNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val = x</span><br><span class="line">#         self.left = None</span><br><span class="line">#         self.right = None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def lowestCommonAncestor(self, root: &apos;TreeNode&apos;, p: &apos;TreeNode&apos;, q: &apos;TreeNode&apos;) -&gt; &apos;TreeNode&apos;:</span><br><span class="line">        while root:</span><br><span class="line">            if p.val &gt; root.val &lt; q.val:</span><br><span class="line">                root = root.right</span><br><span class="line">            elif p.val &lt; root.val &gt; q.val:</span><br><span class="line">                root = root.left</span><br><span class="line">            else:</span><br><span class="line">                return root</span><br><span class="line">        return root</span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>结果</strong></li>
</ul>
<p>实例1：<br><br>执行用时 : 140 ms, 在Lowest Common Ancestor of a Binary Search Tree的Python3提交中击败了37.06% 的用户<br><br>内存消耗 : 17.2 MB, 在Lowest Common Ancestor of a Binary Search Tree的Python3提交中击败了93.84% 的用户</p>
<p>实例2：<br><br>执行用时 : 112 ms, 在Lowest Common Ancestor of a Binary Search Tree的Python3提交中击败了90.42% 的用户<br><br>内存消耗 : 17.2 MB, 在Lowest Common Ancestor of a Binary Search Tree的Python3提交中击败了96.12% 的用户</p>
<ul>
<li><strong>评论区大神</strong></li>
</ul>
<p>1）超短解<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def lowestCommonAncestor(self, root, p, q):</span><br><span class="line">        while (root.val - p.val) * (root.val - q.val) &gt; 0: root = (root.left, root.right)[p.val &gt; root.val]</span><br><span class="line">        return root</span><br></pre></td></tr></table></figure></p>
<p>2）先对输入条件判断<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if p.val &gt; q.val:  # 保证p小</span><br><span class="line">   p, q = q, p</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/05/15/算法学习-二叉树/" data-id="cjvrvovcm0016g8u6qmnofgpb" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/二叉树/">二叉树</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/树/">树</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/05/17/算法学习-二叉树遍历-递归-分治/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          算法学习 二叉树遍历 递归 分治
        
      </div>
    </a>
  
  
    <a href="/2019/05/14/算法学习-映射-集合/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">算法学习 映射 集合</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/博客/">博客</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/map-set/">map & set</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/二叉树/">二叉树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/优先队列/">优先队列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分治/">分治</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/博客命令/">博客命令</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/堆栈-队列/">堆栈&队列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数组-链表/">数组&链表</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/映射-集合/">映射&集合</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/树/">树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/递归/">递归</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/队列/">队列</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/map-set/" style="font-size: 10px;">map & set</a> <a href="/tags/二叉树/" style="font-size: 15px;">二叉树</a> <a href="/tags/优先队列/" style="font-size: 10px;">优先队列</a> <a href="/tags/分治/" style="font-size: 10px;">分治</a> <a href="/tags/博客命令/" style="font-size: 10px;">博客命令</a> <a href="/tags/堆栈-队列/" style="font-size: 10px;">堆栈&队列</a> <a href="/tags/数组-链表/" style="font-size: 10px;">数组&链表</a> <a href="/tags/映射-集合/" style="font-size: 10px;">映射&集合</a> <a href="/tags/树/" style="font-size: 10px;">树</a> <a href="/tags/算法/" style="font-size: 20px;">算法</a> <a href="/tags/递归/" style="font-size: 10px;">递归</a> <a href="/tags/队列/" style="font-size: 10px;">队列</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/05/17/算法学习-贪心算法/">算法学习 贪心算法</a>
          </li>
        
          <li>
            <a href="/2019/05/17/算法学习-二叉树遍历-递归-分治/">算法学习 二叉树遍历 递归 分治</a>
          </li>
        
          <li>
            <a href="/2019/05/15/算法学习-二叉树/">算法学习 二叉树</a>
          </li>
        
          <li>
            <a href="/2019/05/14/算法学习-映射-集合/">算法学习 映射 集合</a>
          </li>
        
          <li>
            <a href="/2019/05/13/算法学习-优先队列/">算法学习 优先队列</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>